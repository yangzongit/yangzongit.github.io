<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>图 | 宗扬coding</title><meta name="author" content="yangzongit"><meta name="copyright" content="yangzongit"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图 1.图 图的定义：图是一种抽象的数据结构，分为点集和边集；又可以因为边集存储的类型分为有向图和无向图 有向图：若边集是有向边的有限集合就叫有向图。有向边就是边是从某个点到另一个点有方向，比如A到B，B不能到A，有向边的方向就是从A到B 无向图：若边集是无向边的有限集合就叫无向图。无向边也可以理解是俩个点之间有一对有向边，比如A能到B，B也能到A 1）图的存储方式①邻接表：针对点集里的每一个点，">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="https://yangzongit.github.io/2024/03/12/%E5%9B%BE/index.html">
<meta property="og:site_name" content="宗扬coding">
<meta property="og:description" content="图 1.图 图的定义：图是一种抽象的数据结构，分为点集和边集；又可以因为边集存储的类型分为有向图和无向图 有向图：若边集是有向边的有限集合就叫有向图。有向边就是边是从某个点到另一个点有方向，比如A到B，B不能到A，有向边的方向就是从A到B 无向图：若边集是无向边的有限集合就叫无向图。无向边也可以理解是俩个点之间有一对有向边，比如A能到B，B也能到A 1）图的存储方式①邻接表：针对点集里的每一个点，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yangzongit.github.io/img/GitHubavatar.png">
<meta property="article:published_time" content="2024-03-12T10:36:43.000Z">
<meta property="article:modified_time" content="2024-05-20T07:30:53.128Z">
<meta property="article:author" content="yangzongit">
<meta property="article:tag" content="原创">
<meta property="article:tag" content="算法与数据结构">
<meta property="article:tag" content="图">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yangzongit.github.io/img/GitHubavatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yangzongit.github.io/2024/03/12/%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-20 15:30:53'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/GitHubavatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="宗扬coding"><span class="site-name">宗扬coding</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-03-12T10:36:43.000Z" title="Created 2024-03-12 18:36:43">2024-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-20T07:30:53.128Z" title="Updated 2024-05-20 15:30:53">2024-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><hr>
<p>1.图</p>
<p>图的定义：图是一种抽象的数据结构，分为点集和边集；又可以因为边集存储的类型分为有向图和无向图</p>
<p>有向图：若边集是有向边的有限集合就叫有向图。有向边就是边是从某个点到另一个点有方向，比如A到B，B不能到A，有向边的方向就是从A到B</p>
<p>无向图：若边集是无向边的有限集合就叫无向图。无向边也可以理解是俩个点之间有一对有向边，比如A能到B，B也能到A</p>
<p>1）图的存储方式<br>①邻接表：针对点集里的每一个点，建立一个表，在点旁边放它相邻的点。如果边有权值的话，邻接表里在每个点旁边的邻居点可以封装个数据项作为权值<br>​<img src="/assets/image-20240312190809-9cc5rh2.png" alt="image"><img src="/assets/image-20240312190826-780erfs.png" alt="image"><br>②邻接矩阵：矩阵一定是正方形的（因为矩阵里存放的是点和点俩俩之间的边），矩阵的每一行每一列都代表着一个点，矩阵的第i行第j列表示的是第i行代表的点到第j列代表的点的边的距离，自己到自己的距离是0，如果俩个点之间不连通就是正无穷</p>
<p>​<img src="/assets/image-20240312191400-g42aopo.png" alt="image">​</p>
<p>有向图和无向图都可以用上述俩种方式表示。图使用邻接表和邻接矩阵各有优缺点：<strong>邻接矩阵可以直接查出来每条边，邻接表可以查出来每个点有几个邻居点，邻接矩阵使用的空间比邻接表大。（邻接表是以点为出发，邻接矩阵是以边为出发）</strong></p>
<p>表达图的方式有很多种，不一定是邻接表和邻接矩阵，也可能是其他特殊的结构（数组等）。所以图的算法即便是不难，但是遇到不同表达方式的图也要重新coding，图的题就麻烦在这。<strong>所以遇到这种题，把熟练的图的表达方式的算法当作接口，再写一个接口使问题中图的表达方式转化成熟练的图的表达方式即可。</strong> 比如解决问题的算法是按邻接表写的，但是实际问题是数组存储图，就写个接口将数组转化成邻接表存储。这种方法比临场再去根据新的数据结构实现算法要快而且稳。</p>
<p>2）图的表达方式（左神推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;<span class="comment">//点集，key表示点的编号, value表示实际的点</span></span><br><span class="line">	<span class="keyword">public</span> HashSet&lt;Edge&gt; edges;<span class="comment">//边集</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span>&#123;</span><br><span class="line">		nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> value;<span class="comment">//数据项，可以更改基础类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> in;<span class="comment">//点的入度，就是有多少个点所发散出来的边是指向这里的，就是有多少个点指向这个点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> out;<span class="comment">//点的出度，从自己这个点出去指向了多少个点</span></span><br><span class="line"> 	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;<span class="comment">//由当前这个点出发，由它发散出去的边连向的点；</span></span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;<span class="comment">//由当前这个点出发，发散出去的边</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		out = <span class="number">0</span>;</span><br><span class="line">		nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> weight;<span class="comment">//权值（距离）</span></span><br><span class="line">	<span class="keyword">public</span> Node from;<span class="comment">//从哪里来</span></span><br><span class="line">	<span class="keyword">public</span> Node to;<span class="comment">//到哪里去</span></span><br><span class="line">	<span class="comment">//这里表达是有向边，无向边不用管，用俩个有向边拼起来就行</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node from, Node to)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">		<span class="built_in">this</span>.from = from;</span><br><span class="line">		<span class="built_in">this</span>.to = to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）<strong>图的转化</strong>（示例） <strong>(将实际问题的图的表示方式转化成自己熟悉的图的表示方式）</strong></p>
<p>​<img src="/assets/image-20240312195511-s9p262v.png" alt="image">​</p>
<p>比如给的图的表达方式是上图所示，用二维数组表达</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(Integer[][] matrix)</span>&#123;</span><br><span class="line">	<span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> matrix[i][<span class="number">1</span>];</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> matrix[i][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span>(!graph.nodes.containsKey(from))&#123;<span class="comment">//如果from的节点不存在图中</span></span><br><span class="line">			graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(from));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!graph.nodes.containsKey(to))&#123;<span class="comment">//如果to的节点不存在图中</span></span><br><span class="line">			graph.nodes.put(to, <span class="keyword">new</span> <span class="title class_">Node</span>(to));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">		<span class="type">Edge</span> <span class="variable">newEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">		fromNode.nexts.add(toNode);</span><br><span class="line">		fromNode.out++;</span><br><span class="line">		toNode.in++;</span><br><span class="line">		fromNode.edges.add(newEdge);</span><br><span class="line">		graph.edges.add(newEdge);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际数据结构的使用情况，结合题目使用，假如题目不需要入度和出度，就可以不设立入度和出度。</p>
<p>‍</p>
<p>2.图的算法（算法要用熟悉的图结构写熟练，这样才知道怎么根据某个题目特殊定制）</p>
<p>1）图的宽度优先遍历(BFS)<br>①利用队列实现<br>②从源节点开始依次按照宽度进队列，然后弹出<br>③每弹出一个点，把该节点所有没有进过队列的邻接点放入队列<br>④直到队列变空</p>
<p>相比于二叉树的BFS，图可能成环，所以算法要有预防在环里死循环的机制 <strong>（利用HashSet）</strong></p>
<p>​<img src="/assets/image-20240313122651-7j6jinp.png" alt="image">​</p>
<p>对于上面的无向图来说，以A点出发，宽度优先遍历的顺序是ACBED、ABCED、AEBCD都可以，也就是说从A出发接下来的同一层的顺序无所谓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法思路：</span></span><br><span class="line"><span class="comment">//准备一个队列，再准备了一个HashSet</span></span><br><span class="line"><span class="comment">//先把第一个节点放入队列里，然后用一个循环判断队列是否为空</span></span><br><span class="line"><span class="comment">//如果不为空则弹出，弹出以后进行当前节点的处理行为，然后遍历当前节点的nexts集合</span></span><br><span class="line"><span class="comment">//如果nexts里的节点不在HashSet里存在，将节点放进HashSet里和队列里</span></span><br><span class="line"><span class="comment">//HashSet用来确保每个节点只进入队列一次（避免有向图进入环，避免无向图回到原点）</span></span><br><span class="line"><span class="comment">//如果图里的每个点都用一个数字表示，没有其他的，并且是有限范围的。</span></span><br><span class="line"><span class="comment">//可以放到数组里，利用数组下标进行寻址，这样常数时间比哈希表快</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	queue.add(node);</span><br><span class="line">	set.add(node);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">		System.out.println(cur.value);<span class="comment">//打印行为可以换成处理行为</span></span><br><span class="line">		<span class="keyword">for</span>(Node next : cur.nexts)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">				set.add(next);</span><br><span class="line">				queue.add(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>‍</p>
<p>2）深度优先遍历(DFS)<br>①利用栈实现<br>②从源节点开始把节点按照深度放入栈，然后弹出<br>③每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈<br>④直到栈变空</p>
<p>​<img src="/assets/image-20240313131004-dpc74hr.png" alt="image">​</p>
<p>上图，深度优先遍历的顺序是A-&gt;B-&gt;C-&gt;D-&gt;E，先一条路走到底，然后再往上看还有没有路能走，找到路了再一条路走到底。其实和二叉树的先序遍历很像</p>
<p>‍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法思路：</span></span><br><span class="line"><span class="comment">//深度优先遍历处理的时候，是一个点进栈的时候处理，并非宽度优先遍历的弹出时候处理</span></span><br><span class="line"><span class="comment">//栈里永远都是现在走的深度的路径</span></span><br><span class="line"><span class="comment">//每个节点先走第一条没走过的路，走完以后返回再走第二条没走过的路</span></span><br><span class="line"><span class="comment">//这样就完成了深度优先遍历，栈是用来记录当前深度的路径，HashSet是保证走过的路不再走</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">	HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	stack.add(node);</span><br><span class="line">	set.add(node);</span><br><span class="line">	System.out.println(node.value);</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">		<span class="keyword">for</span>(Node next : cur.nexts)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">				stack.push(cur);<span class="comment">//为什么要把原来的点压栈回去，因为原来的点还没有遍历完nexts</span></span><br><span class="line">				stack.push(next);<span class="comment">//后把下一个节点压栈，这样先出栈的就是下一个节点</span></span><br><span class="line">				set.add(next);</span><br><span class="line">				System.out.println(next.value);</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//每次进入栈的节点都是nexts集合里第一个不在set里存在的节点，这样就能一条路走到底</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）拓扑排序算法<br>适用范围:<strong>要求有向图，且有入度为0的节点，且没有环</strong></p>
<p>拓扑排序算法非常常用，工程上的依赖编译顺序就是使用了拓扑排序。每个包和对应依赖的包可以认为是一张图</p>
<p>​<img src="/assets/image-20240313133753-v19u4pz.png" alt="image">​</p>
<p>比如上述这张图，肯定是先编译E再编译DC，再编译B，再编译A的</p>
<p>所以拓扑排序就是解决做事情的顺序，使所有的点的依赖环境都具备</p>
<p>算法思路：<br>①找入度为0的点，拿出来处理，然后把它和它的影响从图中擦掉<br>②重复①，直到所有点都被处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bfs和dfs都只需要传点参，拓扑排序需要传图参了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line">	<span class="comment">//key:某一个node</span></span><br><span class="line">	<span class="comment">//value:剩余的入度</span></span><br><span class="line">	HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">//入度为0的点才能进这个队列</span></span><br><span class="line">	<span class="comment">//下面的过程做了把所有点里真实入度为0的点放入队列</span></span><br><span class="line">	Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Node node : graph.nodes.values())&#123;</span><br><span class="line">		inMap.put(node, node.in);</span><br><span class="line">		<span class="keyword">if</span>(node.in == <span class="number">0</span>)&#123;</span><br><span class="line">			zeroInQueue.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//********************************</span></span><br><span class="line">	<span class="comment">//拓扑排序的结果，依次加入result</span></span><br><span class="line">	List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span>(!zeroInQueue.isEmpty())&#123;<span class="comment">//入度为0的队列</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">		result.add(cur);</span><br><span class="line">		<span class="keyword">for</span>(Node next : cur.nexts)&#123;</span><br><span class="line">			inMap.put(next, inMap.get(next) - <span class="number">1</span>);<span class="comment">//擦掉入度为0的点对其他点的影响</span></span><br><span class="line">			<span class="keyword">if</span>(inMap.get(next) == <span class="number">0</span>)&#123;<span class="comment">//如果next点的入度为0了</span></span><br><span class="line">				zeroInQueue.add(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码的核心就是，用哈希表存储某个节点的入度，在哈希表里对入度进行修改，而不是修改Node数据结构里的入度</span></span><br></pre></td></tr></table></figure>

<p>4）生成最小生成树的俩个算法（k算法和p算法）</p>
<p>最小生成树：在保证每个点的连通性的情况下，边的权值是最小的</p>
<p>​<img src="/assets/image-20240313154629-ke76pqr.png" alt="image">———-&gt;(最小生成树）<img src="/assets/image-20240313154938-sqqjg4m.png" alt="image">​</p>
<p>‍</p>
<p>Ⅰ）kruskal算法<br>适用范围:<strong>要求无向图</strong></p>
<p>算法思路：从边的角度出发，将边按权重排序，从权重最小的边开始考虑，看加上这条边会不会形成环。如果会的话就不要这条边，继续考虑下一条，直到所有的边都考虑完。所以这个算法的重点就在于，怎么考察边在加上之后会不会形成环这件事。</p>
<p>那怎么做到考察边在加上之后会不会形成环这件事，用以下的方法：<br>①一开始每个点都是一个集合，然后每考虑一个边，找到它的from和to的点是不是一个集合；<br>②如果不是，将这俩个点的集合合并；如果是，就说明加上这条边以后会成环；<br>③每个边都考虑一下，直到所有的边找完</p>
<p>所以只要使用某种机制，完成上述这种集合查询和集合合并的事情，算法就能实现。而这种机制使用到的最好的数据结构就是<strong>并查集（coding又简单，做合并查询都是常数级别操作）</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的并查集功能实现</span></span><br><span class="line"><span class="comment">//实现很简单，但是没有并查集快</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySets</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Node, List&lt;Node&gt;&gt; setMap;<span class="comment">//哈希表里能查出这个点对应的集合</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MySets</span><span class="params">(List&lt;Node&gt; nodes)</span>&#123;<span class="comment">//构造函数，传点集参数</span></span><br><span class="line">		<span class="keyword">for</span>(Node cur : nodes)&#123;<span class="comment">//每个点最开始属于的集合都只有它自身</span></span><br><span class="line">			List&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">			set.add(cur);</span><br><span class="line">			setMap.put(cur, set);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(Node from, Node to)</span>&#123;<span class="comment">//判断俩个集合是否为同一个集合</span></span><br><span class="line">		List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">		List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">		<span class="keyword">return</span> fromSet == toSet;<span class="comment">//判断内存地址即可</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Node from, Node to)</span>&#123;<span class="comment">//合并俩个集合</span></span><br><span class="line">		List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">		List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">		<span class="keyword">for</span>(Node toNode : toSet)&#123;<span class="comment">//把toSet里所有的点放进fromSet里</span></span><br><span class="line">			fromSet.add(toNode);</span><br><span class="line">			setMap.put(toNode, fromSet);<span class="comment">//再把toSet里所有的点的对应的集合改成fromSet</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k算法的code</span></span><br><span class="line"><span class="comment">//这里使用的是并查集的结构实现的算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">kruskalMST</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line">	<span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">	unionFind.makeSets(graph.nodes.values());</span><br><span class="line">	PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EdgeComparator</span>());</span><br><span class="line">	<span class="keyword">for</span>(Edge edge : graph.edges)&#123;<span class="comment">//M条边</span></span><br><span class="line">		priorityQueue.add(edge);<span class="comment">//O(logM)</span></span><br><span class="line">	&#125;<span class="comment">//利用比较器和堆结构把边排序</span></span><br><span class="line">	Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;<span class="comment">//M条边</span></span><br><span class="line">		<span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();<span class="comment">//O(logM)，弹出的边为权值较小的边</span></span><br><span class="line">		<span class="keyword">if</span>(!unionFind.isSameSet(edge.from, edge.to)&#123;<span class="comment">//O(1)</span></span><br><span class="line">			result.add(edge);</span><br><span class="line">			unionFind.union(edge.from, edge.to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EdgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Edge&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge o1, Edge o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ⅱ）prim算法<br>适用范围:<strong>要求无向图</strong></p>
<p>算法思路：p算法从点的角度出发，到一个点以后，这个点被加入HashSet里，表示已经到达过了；这个点的所有边就被认为解锁了（在图里面打√的表示解锁），然后找下一个点：通过找解锁的边中最小权值的，看这个边的to点是不是不在Set里（也就是没到达过的点）；如果是，那么就说明这条边就是要找的边（在图里面划下划线的表示边被选中）；然后这时来到了下一个点，下一个点又有解锁的边，然后继续找最小权值的符合to点不在Set里的边，直到把所有点都找完，算法结束。</p>
<p>​<img src="/assets/image-20240313191549-5sdvp7e.png" alt="image">—-&gt;（从A点开始）<img src="/assets/image-20240313192810-1zhnl00.png" alt="image">(打x的表示，是最小权值但是不符合俩边中有一点没到达过的边）</p>
<p>‍</p>
<p><strong>关于k算法和p算法数据结构不同的问题：</strong></p>
<p>p算法因为是从点出发的，它每一次找边一定会找到新点，并且只用看边的俩头的点在不在HashSet里，所以不需要k算法那种复杂的集合结构，只需要使用一个哈希表就行。<br>k算法是从边出发的，所以过程中的某一条边可能是连通俩个已经连通的点集的，查询这条边上俩个点各自属于的集合，不像p算法的边上一次只有一个新点。所以需要复杂的集合结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">primMST</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line">	<span class="comment">//解锁的边进入小根堆</span></span><br><span class="line">	PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">EdgeComparator</span>());</span><br><span class="line">	HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//已经到达的点</span></span><br><span class="line">	Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//依次选中的边在result里</span></span><br><span class="line">	<span class="keyword">for</span>(Node node : graph.nodes.values())&#123;<span class="comment">//随便的一个点，这个for循环是为了解决森林问题（就是整体不是连通的，是有一部分一部分连通的区域组成的，这些区域互相之间并不连通）</span></span><br><span class="line">										  <span class="comment">//如果认为图本身就是连通的，可以不需要这个for循环</span></span><br><span class="line">		<span class="comment">//node 是开始点</span></span><br><span class="line">		<span class="keyword">if</span>(!set.contains(node))&#123;</span><br><span class="line">			set.add(node);<span class="comment">//表示这个点已经到达过了</span></span><br><span class="line">			<span class="keyword">for</span>(Edge edge : node.edges)&#123;<span class="comment">//由一个点，解锁所有相连的边</span></span><br><span class="line">				priorityQueue.add(edge);<span class="comment">//解锁的边</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(!priorityQueue.isEmpty())&#123;</span><br><span class="line">				<span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();<span class="comment">//弹出解锁的边中最小权值的边</span></span><br><span class="line">				<span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;<span class="comment">//查看它的to点是不是新点，from点不是新点，因为边是由于from点解锁的</span></span><br><span class="line">				<span class="keyword">if</span>(!set.contains(toNode))&#123;<span class="comment">//不存在set里即为新点</span></span><br><span class="line">					set.add(toNode);</span><br><span class="line">					result.add(edge);<span class="comment">//这条边符合条件，被选中</span></span><br><span class="line">					<span class="keyword">for</span>(Edge nextEdge : toNode.edges)&#123;<span class="comment">//新解锁的边</span></span><br><span class="line">						priorityQueue.add(nextEdge);</span><br><span class="line">						<span class="comment">//这里会把重复的边放到优先级队列里，但是不影响结果</span></span><br><span class="line">						<span class="comment">//如果要筛选这个边有没有存在过优先级队列里，要多一个HashSet存边但是没必要，只是增加了一点常数时间</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）Dijkstra算法（迪杰斯特拉算法）</p>
<p>适用范围:没有累加和权值为负数的环（有累加和权值为负数的环时候，锁死的记录可能就会不对）</p>
<p>这个算法是一个<strong>单元最短路径算法</strong>：规定一个出发点，然后从这个出发点到其他的节点最短距离是多少，对于不可达的点（可认为是无穷大）</p>
<p>算法思路：准备一个表，假如从A点出发，这个表最开始记录的是每个节点到A的距离为正无穷大；然后初始化表，把A点到A点的距离设为0；然后遍历A点的边，看通过这个边的权值加A点到A点的距离，有没有比某个点到A点在表里的距离更小，如果有就用它们的和把表的数据替换；遍历完所有的边以后，在表里把A点到A点的距离锁死（锁死的记录是永远留在表里不变并且不再使用的），不再修改这个距离；如果遍历完边的节点是B，那就在表里把B点到A点的距离锁死。然后在剩下的表里的记录中选个最小的点继续进行操作，每操作完一个点就把这个点到A点的距离数据锁死；直到遍历完所有的点的所有的边，所有的点的数据都被锁死以后，就是答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">	<span class="comment">//从head点出发到所有点的最小距离</span></span><br><span class="line">	<span class="comment">//key:从head出发到达key</span></span><br><span class="line">	<span class="comment">//value:从head出发到达key的最小距离</span></span><br><span class="line">	<span class="comment">//如果在表里没有T的记录，含义是从head出发到T这个点的距离为正无穷</span></span><br><span class="line">	HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	distanceMap.put(head, <span class="number">0</span>);<span class="comment">//head到head的距离为0</span></span><br><span class="line">	<span class="comment">//已经求过距离的节点，存在selectedNodes中，以后再也不碰</span></span><br><span class="line">	HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">	<span class="keyword">while</span>(minNode != <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> distanceMap.get(minNode);</span><br><span class="line">		<span class="keyword">for</span>(Edge edge : minNode.edges)&#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;</span><br><span class="line">			<span class="keyword">if</span>(!distanceMap.containsKey(toNode))&#123;</span><br><span class="line">				distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				distanceMap.put(toNode, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		selectedNodes.add(minNode);</span><br><span class="line">		minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getMinDistanceAndUnselectedNode</span><span class="params">(</span></span><br><span class="line"><span class="params">//这个算法的优化就是在这个方法把数据结构改成堆的形式</span></span><br><span class="line"><span class="params">//但是这个堆得是自己修改的堆，不能是系统的堆</span></span><br><span class="line"><span class="params">//因为最小节点遍历边以后会改变堆内部的结构</span></span><br><span class="line"><span class="params">//当需要改变堆内部结构的时候都需要使用自己写的堆</span></span><br><span class="line"><span class="params">		HashMap&lt;Node, Integer&gt; distanceMap, </span></span><br><span class="line"><span class="params">		HashSet&lt;Node&gt; touchedNodes)</span>&#123;</span><br><span class="line">	<span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">for</span>(Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet())&#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">		<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">		<span class="keyword">if</span>(!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance)&#123;</span><br><span class="line">			minNode = node;</span><br><span class="line">			minDistance = distance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进后的dijkstra算法</span></span><br><span class="line"><span class="comment">//从head出发，所有能到达的节点，生成到达每个节点的最小路径记录并返回</span></span><br><span class="line"><span class="comment">/* 					主算法						*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title function_">dijkstra2</span><span class="params">(Node head, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">NodeHeap</span> <span class="variable">nodeHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeHeap</span>(size);</span><br><span class="line">	nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);<span class="comment">//没有就add，更小就update，不小就ignore</span></span><br><span class="line">	HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span>(!nodeHeap.isEmpty())&#123;</span><br><span class="line">		<span class="type">NodeRecord</span> <span class="variable">record</span> <span class="operator">=</span> nodeHeap.pop();</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> record.node;</span><br><span class="line">		<span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> record.distance;</span><br><span class="line">		<span class="keyword">for</span>(Edge edge : cur.edges)&#123;</span><br><span class="line">			nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">		&#125;</span><br><span class="line">		result.put(cur, distance);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 					NodeRecord结构						*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeRecord</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Node node;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> distance;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NodeRecord</span><span class="params">(Node node, <span class="type">int</span> distance)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.node = node;</span><br><span class="line">		<span class="built_in">this</span>.distance = distance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 					堆结构						*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeHeap</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node[] nodes;<span class="comment">//堆结构</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;<span class="comment">//可以查某个节点的index，可以查Node在哪</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;<span class="comment">//Node到Head的最短距离</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//一共有多少个节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NodeHeap</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">		nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">		heapIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="type">int</span> distance)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(inHeap(node))&#123;<span class="comment">//node在堆上</span></span><br><span class="line">			distanceMap.put(node, Math.min(distanceMap.get(node), distance));<span class="comment">//修改只能修改更小</span></span><br><span class="line">			insertHeapify(node, heapIndexMap.get(node));<span class="comment">//更小就只能往上heapify</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!isEntered(node))&#123;<span class="comment">//node没进过堆结构</span></span><br><span class="line">			nodes[size] = node;</span><br><span class="line">			heapIndexMap.put(node, size);</span><br><span class="line">			distanceMap.put(node, distance);</span><br><span class="line">			insertHeapify(node, size++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//进过堆不在堆上就是啥都不做（算完的节点，就是锁定的）</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> NodeRecord <span class="title function_">pop</span><span class="params">()</span>&#123;<span class="comment">//弹出方法</span></span><br><span class="line">		<span class="type">NodeRecord</span> <span class="variable">nodeRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeRecord</span>(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));<span class="comment">//把堆顶弹出</span></span><br><span class="line">		swap(<span class="number">0</span>, size - <span class="number">1</span>);<span class="comment">//堆顶和堆最后的位置数据交换</span></span><br><span class="line">		heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>);<span class="comment">//把弹出的数在heapIndexMap里改为-1，表示已经弹出</span></span><br><span class="line">		distanceMap.remove(nodes[size - <span class="number">1</span>]);<span class="comment">//删除distanceMap里的值</span></span><br><span class="line">		nodes[size - <span class="number">1</span>] = <span class="literal">null</span>;<span class="comment">//数组里标空</span></span><br><span class="line">		heapify(<span class="number">0</span>, --size);<span class="comment">//把刚换到堆顶的进行heapify调整</span></span><br><span class="line">		<span class="keyword">return</span> nodeRecord;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertHeapify</span><span class="params">(Node node, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>]))&#123;</span><br><span class="line">			swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">			index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">							? left + <span class="number">1</span> : left;</span><br><span class="line">			smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">			<span class="keyword">if</span>(smallest == index)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(smallest, index);</span><br><span class="line">			index = smallest;</span><br><span class="line">			left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEntered</span><span class="params">(Node node)</span>&#123;<span class="comment">//查node进没进来过</span></span><br><span class="line">		<span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inHeap</span><span class="params">(Node node)</span>&#123;<span class="comment">//看node在不在堆上</span></span><br><span class="line">		<span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;	<span class="comment">//一个节点弹出以后heapIndexMap上的记录改为-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span>&#123;</span><br><span class="line">		heapIndexMap.put(nodes[index1], index2);<span class="comment">//先改哈希表</span></span><br><span class="line">		heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> nodes[index1];<span class="comment">//再在数组交换</span></span><br><span class="line">		nodes[index1] = nodes[index2];</span><br><span class="line">		nodes[index2] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://yangzongit.github.io">yangzongit</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://yangzongit.github.io/2024/03/12/%E5%9B%BE/">https://yangzongit.github.io/2024/03/12/%E5%9B%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%88%9B/">原创</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a><a class="post-meta__tags" href="/tags/%E5%9B%BE/">图</a></div><div class="post_share"><div class="social-share" data-image="/img/GitHubavatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/15/%E5%89%8D%E7%BC%80%E6%A0%91%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="前缀树和贪心算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">前缀树和贪心算法</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">二叉树</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-10</div><div class="title">二叉树</div></div></a></div><div><a href="/2024/03/15/%E5%89%8D%E7%BC%80%E6%A0%91%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="前缀树和贪心算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-15</div><div class="title">前缀树和贪心算法</div></div></a></div><div><a href="/2024/03/16/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89/" title="暴力递归（回溯）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="title">暴力递归（回溯）</div></div></a></div><div><a href="/2024/03/04/%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="认识复杂度和简单排序算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-04</div><div class="title">认识复杂度和简单排序算法</div></div></a></div><div><a href="/2024/03/09/%E9%93%BE%E8%A1%A8/" title="链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-09</div><div class="title">链表</div></div></a></div><div><a href="/2024/03/06/%E8%AE%A4%E8%AF%86O(NlogN)%E7%9A%84%E6%8E%92%E5%BA%8F/" title="认识O(NlogN)的排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">认识O(NlogN)的排序</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/GitHubavatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yangzongit</div><div class="author-info__description">宗扬的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yangzongit"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">图</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/29/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="Java反射机制">Java反射机制</a><time datetime="2024-05-29T06:09:10.000Z" title="Created 2024-05-29 14:09:10">2024-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/16/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89/" title="暴力递归（回溯）">暴力递归（回溯）</a><time datetime="2024-03-16T07:44:59.000Z" title="Created 2024-03-16 15:44:59">2024-03-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/15/%E5%89%8D%E7%BC%80%E6%A0%91%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" title="前缀树和贪心算法">前缀树和贪心算法</a><time datetime="2024-03-15T04:03:51.000Z" title="Created 2024-03-15 12:03:51">2024-03-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/%E5%9B%BE/" title="图">图</a><time datetime="2024-03-12T10:36:43.000Z" title="Created 2024-03-12 18:36:43">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2024-03-10T09:02:12.000Z" title="Created 2024-03-10 17:02:12">2024-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By yangzongit</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>